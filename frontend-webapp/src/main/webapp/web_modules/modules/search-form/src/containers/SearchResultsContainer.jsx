/**
 * LICENSE_PLACEHOLDER
 **/
import { concat, map } from 'lodash'
import { connect } from '@regardsoss/redux'
import { CatalogEntity } from '@regardsoss/model'
import ResultComponent from '../components/user/ResultComponent'
import CatalogEntitySelector from '../../src/models/catalog/CatalogEntitySelector'
import CatalogEntityActions from '../../src/models/catalog/CatalogEntityActions'


const createBigDatas = () => {
  const objects = []
  let i = 0
  for (i = 1000; i < 1000; i += 1) {
    objects.push({
      content: {
        id: 1000 + i,
        sip_id: 10000 + i,
        label: `Film_${i}`,
        type: 'DATAOBJECT',
        tags: ['col:movie', 'ds:NYCLibrary'],
        attributes: {
          format: 'blueray',
          language: 'English',
        },
        geometry: {},
      },
    })
  }
  return objects
}
/**
 * React container to manage search requests and display results.
 * Search queries are generated by the FormComponent and used by this container.
 */
class SearchResultsContainer extends React.Component {

  static propTypes = {
    searchQuery: React.PropTypes.string,
    // Set by mapStateToProps
    // eslint-disable-next-line react/no-unused-prop-types
    results: React.PropTypes.objectOf(CatalogEntity),
    resultsFetching: React.PropTypes.bool,
    pageMetadata: React.PropTypes.shape({
      number: React.PropTypes.number,
      totalElements: React.PropTypes.number,
      size: React.PropTypes.number,
    }),
    // Set by mapDispatchToProps
    search: React.PropTypes.func,
  }

  constructor(props) {
    super()
    this.state = {
      currentStartIndex: 0,
      allEntities: createBigDatas(),
      nbResultsByPage: 20,
    }
  }

  /**
   * Run initial search
   */
  componentWillMount() {
    this.props.search(0, this.state.nbResultsByPage, this.props.searchQuery)
  }

  /**
   * Update search
   * @param nextProps
   */
  componentWillReceiveProps(nextProps) {
    // If a new search query is proveded, reset results and run new search
    if (nextProps.searchQuery !== this.props.searchQuery) {
      console.log('NEW REQUEST')
      this.setState({
        allEntities: createBigDatas(),
      })
      this.props.search(0, this.state.nbResultsByPage, nextProps.searchQuery)
    }
    if (nextProps.resultsFetching === false && this.props.resultsFetching === true) {
      console.log('NEW Entities', nextProps.results)
      const newResults = map(nextProps.results, result => result)
      this.setState({
        allEntities: concat([], this.state.allEntities, newResults),
      })
    }
  }

  getResultsNextPage = () => {
    if (!this.props.resultsFetching) {
      const newIndex = this.state.currentStartIndex + this.state.allEntities.length
      console.log('Running search', newIndex)
      this.props.search(newIndex, this.state.nbResultsByPage, this.props.searchQuery)

      this.setState({
        currentStartIndex: this.state.currentStartIndex + this.state.nbResultsByPage,
      })
    }
  }


  render() {
    let infinite = true
    if (this.props.pageMetadata) {
      infinite = this.state.allEntities.length < this.props.pageMetadata.totalElements
    }
    return (
      <ResultComponent
        entities={this.state.allEntities}
        getNextPage={this.getResultsNextPage}
        infinite={infinite}
        resultsFetching={this.props.resultsFetching}
      />
    )
  }

}

const mapStateToProps = state => ({
  results: CatalogEntitySelector.getList(state),
  pageMetadata: CatalogEntitySelector.getMetaData(state),
  resultsFetching: CatalogEntitySelector.isFetching(state),
})

const mapDispatchToProps = dispatch => ({
  // Run search query
  search: (start, pageSize, queryParams) =>
    dispatch(CatalogEntityActions.fetchPagedEntityList(start, pageSize, { queryParams })),
})

export default connect(mapStateToProps, mapDispatchToProps)(SearchResultsContainer)
