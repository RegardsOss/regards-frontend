/**
 * LICENSE_PLACEHOLDER
 **/
import isEqual from 'lodash/isEqual'
import reduce from 'lodash/reduce'
import values from 'lodash/values'
import sortBy from 'lodash/sortBy'
import find from 'lodash/find'


import FlatButton from 'material-ui/FlatButton'
import ListView from 'material-ui/svg-icons/action/list'
import TableView from 'material-ui/svg-icons/action/view-module'
import DatasetLibrary from 'material-ui/svg-icons/image/collections-bookmark'
import DataLibrary from 'material-ui/svg-icons/av/library-books'
import ShowFacetsSearch from 'material-ui/svg-icons/action/find-in-page'

import { themeContextType } from '@regardsoss/theme'
import { i18nContextType } from '@regardsoss/i18n'
import { TableContainer, ShowableAtRender } from '@regardsoss/components'
import { LazyModuleComponent } from '@regardsoss/modules'
import {
  AttributeModel,
  AttributeModelController,
  AttributeConfiguration,
  AttributeConfigurationController,
  AttributesRegroupementConfiguration,
} from '@regardsoss/model'
import { getTypeRender } from '@regardsoss/attributes-common'
import { CatalogEntityActions } from '../../../models/catalog/CatalogEntityActions'
import CatalogEntitySelector from '../../../models/catalog/CatalogEntitySelector'
import ListViewEntityCellComponent from './ListViewEntityCellComponent'
import TableSortFilter from './TableSortFilter'
import TableSelectAllFilter from './TableSelectAllFilter'


const RESULTS_TABLE_NAME = 'search-results-table'
/**
 * React container to manage search requests and display results.
 * Search queries are generated by the FormComponent and used by this container.
 * @author SÃ©bastien binda
 */
class SearchResultsComponent extends React.Component {

  /** View modes enumeration */
  static ViewModes = {
    LIST: 'list',
    TABLE: 'table',
  }

  static propTypes = {
    // static configuration
    appName: React.PropTypes.string,
    project: React.PropTypes.string,
    allowingFacettes: React.PropTypes.bool.isRequired,


    // dynamic display control
    showingDataobjects: React.PropTypes.bool.isRequired,     // is Currently showing data objects (false: showing datasets)
    viewMode: React.PropTypes.oneOf(values(SearchResultsComponent.ViewModes)), // current mode
    showingFacettes: React.PropTypes.bool.isRequired,
    filters: React.PropTypes.arrayOf(React.PropTypes.shape({
      filterKey: React.PropTypes.string.isRequired,
      filterLabel: React.PropTypes.string.isRequired,
      openSearchQuery: React.PropTypes.string.isRequired,
    })),
    searchQuery: React.PropTypes.string.isRequired,

    // Attributes configurations for results columns
    // eslint-disable-next-line react/no-unused-prop-types
    attributesConf: React.PropTypes.arrayOf(AttributeConfiguration),
    // eslint-disable-next-line react/no-unused-prop-types
    attributesRegroupementsConf: React.PropTypes.arrayOf(AttributesRegroupementConfiguration),
    attributeModels: React.PropTypes.objectOf(AttributeModel),

    // control
    resultPageActions: React.PropTypes.instanceOf(CatalogEntityActions).isRequired,
    onFiltersChanged: React.PropTypes.func.isRequired,
    // eslint-disable-next-line react/no-unused-prop-types
    onSelectDataset: React.PropTypes.func.isRequired,
    // eslint-disable-next-line react/no-unused-prop-types
    onSelectSearchTag: React.PropTypes.func.isRequired,
    onShowDatasets: React.PropTypes.func.isRequired,
    onShowDataobjects: React.PropTypes.func.isRequired,
    onShowListView: React.PropTypes.func.isRequired,
    onShowTableView: React.PropTypes.func.isRequired,
    onSortChanged: React.PropTypes.func.isRequired,
    onToggleShowFacettes: React.PropTypes.func.isRequired,
  }

  static contextTypes = {
    ...i18nContextType,
    ...themeContextType,
  }

  componentWillMount = () => this.updateState({}, this.props)

  componentWillReceiveProps = nextProps => this.updateState(this.props, nextProps)

  /**
   * Sorting adaptation for parent container (to avoid runtime lambdas)
   */
  onSortByColumn = (column, type, clear) => {
    this.props.onSortChanged(column.attributes[0], type, clear)
  }


  /**
   * Builds table columns
   * @param attributesConf : results table attributes columns configuration
   * @param attributesRegroupementsConf: results table attributes regroupement columns configuration
   * @param attributeModels: fetched attribute models (to retrieve attributes)
   */
  buildTableColumns = (attributesConf, attributeModels, attributesRegroupementsConf) =>
    sortBy([
      ...this.buildAttributesColumns(attributesConf, attributeModels),
      ...this.buildAttrRegroupementColumns(attributesRegroupementsConf, attributeModels)], a => a.order ? a.order : 1000)

  buildAttributesColumns = (attributesConf, attributeModels) =>
    reduce(attributesConf, (allColumns, attributeConf) => {
      // map to attributes models then to column
      if (attributeConf.visibility) {
        let attribute
        let fullyQualifiedAttributePathInEntity
        if (AttributeConfigurationController.isStandardAttribute(attributeConf)) {
          // standard attribute
          attribute = AttributeConfigurationController.getStandardAttributeConf(attributeConf.attributeFullQualifiedName)
          fullyQualifiedAttributePathInEntity = AttributeModelController.getStandardAttributeEntityPathName(attributeConf.attributeFullQualifiedName)
        } else {
          // maybe dynamic attribute (if found)
          attribute = find(attributeModels,
            att => AttributeModelController.getAttributeFullyQualifiedName(att) === attributeConf.attributeFullQualifiedName)
          fullyQualifiedAttributePathInEntity = attribute ?
            AttributeModelController.getAttributeFullyQualifiedNameWithoutDefaultFragment(attribute) : null
        }
        // when found, add the corresponding column
        if (attribute) {
          const customCell = getTypeRender(attribute.content.type)
          const isSpecialAttr =
            attribute.content.type === AttributeModelController.ATTRIBUTE_TYPES.THUMBMAIL ||
            attribute.content.type === AttributeModelController.ATTRIBUTE_TYPES.DOWNLOAD_LINK
          return [...allColumns, {
            label: attribute.content.label,
            attributes: [fullyQualifiedAttributePathInEntity],
            sortable: !isSpecialAttr,
            hideLabel: isSpecialAttr,
            fixed: isSpecialAttr ? 50 : undefined,
            customCell: customCell ? {
              component: customCell,
              props: {},
            } : undefined,
            order: attributeConf.order,
          }]
        }
      }
      // ignored attribute
      return allColumns
    }, [])

  buildAttrRegroupementColumns = (attributesRegroupementsConf, attributeModels) =>
    reduce(attributesRegroupementsConf, (allColumns, attrRegroupementConf) => {
      if (attrRegroupementConf.visibility) {
        // 1 -rebuild attributes
        const attributes = reduce(attrRegroupementConf.attributes, (results, attributeId) => {
          const attribute = find(attributeModels, att => att.content.id === attributeId)
          return attribute ?
            [...results, AttributeModelController.getAttributeFullyQualifiedNameWithoutDefaultFragment(attribute)] :
            results
        }, [])
        // 2 - If attributes could be rebuilt, return corresponding columns
        if (attributes && attributes.length) {
          return [...allColumns, {
            label: attrRegroupementConf.label,
            attributes,
            sortable: false,
            order: attrRegroupementConf.order,
          }]
        }
      }
      // ignored regroupement
      return allColumns
    }, [])

  /**
  * Create columns configuration for table view
  * @returns {Array}
  */
  buildListColumns = (tableColumns, { attributeModels, showingDataobjects, onSelectDataset, onSelectSearchTag }) => [{
    label: 'ListviewCell',
    attributes: [],
    customCell: {
      component: ListViewEntityCellComponent,
      props: {
        // click: select a dataset when in dataset mode
        onClick: showingDataobjects ? null : onSelectDataset,
        attributes: attributeModels,
        styles: this.context.moduleTheme.user.listViewStyles,
        onSearchTag: onSelectSearchTag,
        tableColumns: showingDataobjects ? tableColumns : undefined,
        displayCheckBoxes: showingDataobjects,
      },
    },
  }]


  /**
  * Updates component state: stores in state the graphics variable computed from new properties, to avoid render time computing
  * @param oldProperties old properties
  * @param newProperties new properties
  */
  updateState = (oldProperties, newProperties) => {
    const oldState = this.state
    const newState = oldState || {}

    // table columns
    newState.tableColumns = this.buildTableColumns(newProperties.attributesConf, newProperties.attributeModels, newProperties.attributesRegroupementsConf)

    // list columns
    newState.listColumns = this.buildListColumns(newState.tableColumns, newProperties)

    // update state when changed
    if (!isEqual(oldState, newState)) {
      this.setState(newState)
    }
  }

  isInListView = () => this.props.viewMode === SearchResultsComponent.ViewModes.LIST

  isInTableView = () => this.props.viewMode === SearchResultsComponent.ViewModes.TABLE

  /**
   * Returns result tabs actions for results table
   */
  renderTableTabs = () => {
    const { intl: { formatMessage } } = this.context
    const { showingDataobjects, onShowDatasets, onShowDataobjects } = this.props
    // TODO when dataset disabling refactor is done, handle simple tabs removal!
    return [
      <FlatButton
        key="datasets.tab"
        label={formatMessage({ id: 'navigation.datasets.label' })}
        onTouchTap={onShowDatasets}
        icon={<DatasetLibrary />}
        secondary={!showingDataobjects}
        disabled={
          // TODO
          !!false}
      />,
      <FlatButton
        key="dataobjects.tab"
        label={formatMessage({ id: 'navigation.dataobjects.label' })}
        onTouchTap={onShowDataobjects}
        icon={<DataLibrary />}
        secondary={showingDataobjects}
      />,
    ]
  }

  /**
   * Renders table context options (middle area of the header)
   * @return rendered options list
   */
  renderTableContextOptions = () => {
    const { allowingFacettes, showingDataobjects, showingFacettes, onToggleShowFacettes } = this.props
    const { tableColumns } = this.state
    const { intl: { formatMessage } } = this.context

    // TODO add the selection services here
    // TODO ==> extract elements as sub options (because we are in a BIG BIG class!!)
    return [
      this.isInListView() && showingDataobjects ? <TableSelectAllFilter
        key="select.filter.option"
        tableName={RESULTS_TABLE_NAME}
      /> : null,
      this.isInListView() && showingDataobjects ? <TableSortFilter
        key="sort.filter.option"
        onSortByColumn={this.onSortByColumn}
        tableColumns={tableColumns}
        prefixLabel={formatMessage({ id: 'list.sort.prefix.label' })}
        noneLabel={formatMessage({ id: 'list.sort.none.label' })}
      /> : null,
      <ShowableAtRender
        key="facet.filter.option"
        show={allowingFacettes && showingDataobjects}
      >
        <FlatButton
          label={formatMessage({ id: 'navigation.filter.by.facets' })}
          onTouchTap={onToggleShowFacettes}
          icon={<ShowFacetsSearch />}
          secondary={showingFacettes}
        />
      </ShowableAtRender>,
    ]
  }

  /**
   * Returns options for results table
   */
  renderTableRightSideOptions = () => {
    const { showingDataobjects, onShowTableView, onShowListView } = this.props
    const { intl: { formatMessage } } = this.context
    return [
      showingDataobjects ? <FlatButton
        key="view.type.list"
        onTouchTap={onShowListView}
        icon={<ListView
          style={{
            width: 33,
            height: 33,
          }}
        />}
        secondary={this.isInListView()}
        style={{
          minWidth: 45,
        }}
        title={formatMessage({ id: 'view.type.list.button.label' })}
      /> : null,
      showingDataobjects ? <FlatButton
        key="view.type.table"
        onTouchTap={onShowTableView}
        icon={<TableView
          style={{
            width: 30,
            height: 30,
          }}
        />}
        secondary={this.isInTableView()}
        style={{
          minWidth: 45,
        }}
        title={formatMessage({ id: 'view.type.table.button.label' })}
      /> : null,
    ]
  }

  /**
   * Returns dedicated facets filtering area (when shown)
   */
  renderTableHeaderArea = () => {
    const { appName, project, allowingFacettes, showingFacettes,
      showingDataobjects, attributeModels, filters, onFiltersChanged } = this.props

    // when in facet mode, render facet module
    if (showingDataobjects && allowingFacettes && showingFacettes) {
      // when facettes are allowed and visible, use facets module as table header
      const searchFacetsModule = {
        name: 'search-facets',
        active: true,
        applicationId: appName,
        conf: {
          onFiltersChanged,
          filters,
          show: showingFacettes,
          resultsSelectors: CatalogEntitySelector,
          attributeModels,
        },
      }
      return (
        <LazyModuleComponent
          project={project}
          appName={appName}
          module={searchFacetsModule}
        />)
    }
    // when in default mode, let table render results count
    return null
  }

  render() {
    const { moduleTheme: { user: { listViewStyles } } } = this.context
    const { showingDataobjects, viewMode, searchQuery, resultPageActions } = this.props
    const { tableColumns, listColumns } = this.state

    let columns = []
    let lineHeight
    let cellsStyle
    let displayCheckbox
    let displayColumnsHeader
    let showParameters
    if (viewMode === SearchResultsComponent.ViewModes.TABLE && showingDataobjects) {
      columns = tableColumns
      lineHeight = 50
      cellsStyle = null
      displayCheckbox = true
      displayColumnsHeader = true
      showParameters = true
    } else {
      columns = listColumns
      lineHeight = 160
      cellsStyle = listViewStyles.cell
      displayCheckbox = false
      displayColumnsHeader = false
      showParameters = false
    }

    return (
      <TableContainer
        key={`${showingDataobjects ? 'dataobjects' : 'datasets'}-${viewMode}`}
        name={RESULTS_TABLE_NAME}
        PageActions={resultPageActions}
        PageSelector={CatalogEntitySelector}
        pageSize={20}
        displayCheckbox={displayCheckbox}
        columns={columns}
        onSelectionChange={this.resultSelection}
        requestParams={{ queryParams: searchQuery }}
        tableConfiguration={{
          displayColumnsHeader,
          cellsStyle,
          lineHeight,
          displayCheckbox,
          onSortByColumn: this.sortResultsByColumn,
        }}
        tablePaneConfiguration={{
          resultsTabsButtons: this.renderTableTabs(),
          customTableOptions: this.renderTableRightSideOptions(),
          contextOptions: this.renderTableContextOptions(),
          customTableHeaderArea: this.renderTableHeaderArea(),
          displayTableHeader: true,
          displaySortFilter: true,
          showParameters,
        }}
      />
    )
  }
}

export default SearchResultsComponent
